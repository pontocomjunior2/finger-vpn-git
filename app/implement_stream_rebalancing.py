#!/usr/bin/env python3
"""
Script para implementar rebalanceamento autom√°tico de streams
Corrige inst√¢ncias que excedem o limite e redistribui streams
"""

import os
import time
from datetime import datetime, timedelta

import psycopg2
import requests

# Configura√ß√µes
POSTGRES_CONFIG = {
    'host': os.getenv('POSTGRES_HOST', '104.234.173.96'),
    'user': os.getenv('POSTGRES_USER', 'postgres'),
    'password': os.getenv('POSTGRES_PASSWORD', 'Conquista@@2'),
    'database': os.getenv('POSTGRES_DB', 'music_log'),
    'port': int(os.getenv('POSTGRES_PORT', 5432))
}

ORCHESTRATOR_URL = "http://localhost:8001"

def get_db_connection():
    """Conecta ao banco de dados"""
    try:
        return psycopg2.connect(**POSTGRES_CONFIG)
    except Exception as e:
        print(f"‚ùå Erro ao conectar ao banco: {e}")
        return None

def get_active_instances():
    """Obt√©m inst√¢ncias ativas do orquestrador"""
    try:
        response = requests.get(f"{ORCHESTRATOR_URL}/instances", timeout=10)
        if response.status_code == 200:
            data = response.json()
            instances = data.get('instances', [])
            
            # Filtrar apenas inst√¢ncias ativas e com heartbeat recente
            active_instances = []
            cutoff_time = datetime.now() - timedelta(minutes=2)
            
            for instance in instances:
                last_heartbeat = datetime.fromisoformat(instance['last_heartbeat'].replace('Z', '+00:00'))
                if (instance['status'] == 'active' and 
                    last_heartbeat.replace(tzinfo=None) > cutoff_time):
                    active_instances.append(instance)
            
            return active_instances
        else:
            print(f"‚ùå Erro ao obter inst√¢ncias: {response.status_code}")
            return []
    except Exception as e:
        print(f"‚ùå Erro ao conectar com orquestrador: {e}")
        return []

def identify_rebalancing_needs(instances):
    """Identifica necessidades de rebalanceamento"""
    overloaded = []  # Inst√¢ncias com streams > max_streams
    underutilized = []  # Inst√¢ncias com espa√ßo dispon√≠vel
    
    total_streams = 0
    total_capacity = 0
    
    for instance in instances:
        current = instance['current_streams']
        max_streams = instance['max_streams']
        available = max_streams - current
        
        total_streams += current
        total_capacity += max_streams
        
        if current > max_streams:
            excess = current - max_streams
            overloaded.append({
                'server_id': instance['server_id'],
                'current': current,
                'max': max_streams,
                'excess': excess
            })
        elif available > 0:
            underutilized.append({
                'server_id': instance['server_id'],
                'current': current,
                'max': max_streams,
                'available': available
            })
    
    return {
        'overloaded': overloaded,
        'underutilized': underutilized,
        'total_streams': total_streams,
        'total_capacity': total_capacity,
        'utilization': (total_streams / total_capacity * 100) if total_capacity > 0 else 0
    }

def get_streams_to_move(server_id, count):
    """Obt√©m streams espec√≠ficos para mover de uma inst√¢ncia"""
    conn = get_db_connection()
    if not conn:
        return []
    
    try:
        cursor = conn.cursor()
        
        # Buscar streams ativos da inst√¢ncia
        cursor.execute("""
            SELECT stream_id, assigned_at
            FROM orchestrator_stream_assignments 
            WHERE server_id = %s 
            AND status = 'active'
            ORDER BY assigned_at ASC
            LIMIT %s
        """, (server_id, count))
        
        streams = cursor.fetchall()
        return [{'stream_id': s[0], 'assigned_at': s[1]} for s in streams]
        
    except Exception as e:
        print(f"‚ùå Erro ao buscar streams: {e}")
        return []
    finally:
        conn.close()

def move_streams(streams, from_instance, to_instance):
    """Move streams de uma inst√¢ncia para outra"""
    if not streams:
        return True
    
    conn = get_db_connection()
    if not conn:
        return False
    
    try:
        cursor = conn.cursor()
        
        stream_ids = [s['stream_id'] for s in streams]
        
        # Atualizar streams no banco
        cursor.execute("""
            UPDATE orchestrator_stream_assignments 
            SET server_id = %s, assigned_at = NOW()
            WHERE stream_id = ANY(%s) AND server_id = %s
        """, (to_instance, stream_ids, from_instance))
        
        moved_count = cursor.rowcount
        
        if moved_count > 0:
            # Atualizar contadores das inst√¢ncias
            cursor.execute("""
                UPDATE orchestrator_instances 
                SET current_streams = current_streams - %s
                WHERE server_id = %s
            """, (moved_count, from_instance))
            
            cursor.execute("""
                UPDATE orchestrator_instances 
                SET current_streams = current_streams + %s
                WHERE server_id = %s
            """, (moved_count, to_instance))
            
            conn.commit()
            print(f"   ‚úÖ Movidos {moved_count} streams: {from_instance} ‚Üí {to_instance}")
            return True
        else:
            print(f"   ‚ö†Ô∏è  Nenhum stream foi movido")
            return False
            
    except Exception as e:
        print(f"   ‚ùå Erro ao mover streams: {e}")
        conn.rollback()
        return False
    finally:
        conn.close()

def perform_rebalancing(analysis):
    """Executa o rebalanceamento de streams"""
    overloaded = analysis['overloaded']
    underutilized = analysis['underutilized']
    
    if not overloaded:
        print("‚úÖ Nenhuma inst√¢ncia sobrecarregada encontrada")
        return True
    
    if not underutilized:
        print("‚ö†Ô∏è  N√£o h√° inst√¢ncias dispon√≠veis para receber streams")
        return False
    
    print(f"\nüîÑ Iniciando rebalanceamento:")
    print(f"   - Inst√¢ncias sobrecarregadas: {len(overloaded)}")
    print(f"   - Inst√¢ncias dispon√≠veis: {len(underutilized)}")
    
    # Ordenar por prioridade
    overloaded.sort(key=lambda x: x['excess'], reverse=True)  # Mais sobrecarregadas primeiro
    underutilized.sort(key=lambda x: x['available'], reverse=True)  # Mais espa√ßo primeiro
    
    total_moved = 0
    
    for overloaded_instance in overloaded:
        server_id = overloaded_instance['server_id']
        excess = overloaded_instance['excess']
        
        print(f"\nüì§ Processando {server_id} (excesso: {excess} streams):")
        
        remaining_excess = excess
        
        for underutilized_instance in underutilized:
            if remaining_excess <= 0:
                break
            
            target_id = underutilized_instance['server_id']
            available = underutilized_instance['available']
            
            if available <= 0:
                continue
            
            # Calcular quantos streams mover
            to_move = min(remaining_excess, available)
            
            print(f"   üìã Movendo {to_move} streams para {target_id}...")
            
            # Obter streams espec√≠ficos para mover
            streams = get_streams_to_move(server_id, to_move)
            
            if streams:
                success = move_streams(streams, server_id, target_id)
                if success:
                    remaining_excess -= to_move
                    underutilized_instance['available'] -= to_move
                    total_moved += to_move
                else:
                    print(f"   ‚ùå Falha ao mover streams")
            else:
                print(f"   ‚ö†Ô∏è  Nenhum stream encontrado para mover")
        
        if remaining_excess > 0:
            print(f"   ‚ö†Ô∏è  Ainda h√° {remaining_excess} streams em excesso")
    
    print(f"\nüìä Rebalanceamento conclu√≠do:")
    print(f"   - Total de streams movidos: {total_moved}")
    
    return total_moved > 0

def cleanup_orphaned_streams():
    """Remove streams √≥rf√£os (de inst√¢ncias inativas)"""
    print("\nüßπ Limpando streams √≥rf√£os...")
    
    conn = get_db_connection()
    if not conn:
        return False
    
    try:
        cursor = conn.cursor()
        
        # Encontrar streams de inst√¢ncias inativas
        cursor.execute("""
            SELECT s.stream_id, s.server_id
            FROM orchestrator_stream_assignments s
            LEFT JOIN orchestrator_instances i ON s.server_id = i.server_id
            WHERE s.status = 'active' 
            AND (i.status != 'active' OR i.last_heartbeat < NOW() - INTERVAL '5 minutes')
        """)
        
        orphaned_streams = cursor.fetchall()
        
        if not orphaned_streams:
            print("   ‚úÖ Nenhum stream √≥rf√£o encontrado")
            return True
        
        print(f"   üîç Encontrados {len(orphaned_streams)} streams √≥rf√£os")
        
        # Marcar streams como √≥rf√£os para reatribui√ß√£o
        orphaned_ids = [s[0] for s in orphaned_streams]
        
        cursor.execute("""
            UPDATE orchestrator_stream_assignments 
            SET status = 'pending', assigned_at = NOW()
            WHERE stream_id = ANY(%s)
        """, (orphaned_ids,))
        
        conn.commit()
        print(f"   ‚úÖ {cursor.rowcount} streams marcados para reatribui√ß√£o")
        
        return True
        
    except Exception as e:
        print(f"   ‚ùå Erro na limpeza: {e}")
        conn.rollback()
        return False
    finally:
        conn.close()

def reassign_pending_streams():
    """Reatribui streams pendentes para inst√¢ncias ativas"""
    print("\nüîÑ Reatribuindo streams pendentes...")
    
    # Obter inst√¢ncias ativas
    active_instances = get_active_instances()
    if not active_instances:
        print("   ‚ùå Nenhuma inst√¢ncia ativa dispon√≠vel")
        return False
    
    # Filtrar inst√¢ncias com espa√ßo dispon√≠vel
    available_instances = [
        inst for inst in active_instances 
        if inst['current_streams'] < inst['max_streams']
    ]
    
    if not available_instances:
        print("   ‚ö†Ô∏è  Todas as inst√¢ncias est√£o no limite")
        return False
    
    conn = get_db_connection()
    if not conn:
        return False
    
    try:
        cursor = conn.cursor()
        
        # Buscar streams pendentes
        cursor.execute("""
            SELECT stream_id 
            FROM orchestrator_stream_assignments 
            WHERE status = 'pending'
            ORDER BY assigned_at ASC
        """)
        
        pending_streams = cursor.fetchall()
        
        if not pending_streams:
            print("   ‚úÖ Nenhum stream pendente encontrado")
            return True
        
        print(f"   üîç Encontrados {len(pending_streams)} streams pendentes")
        
        # Distribuir streams
        assigned_count = 0
        instance_index = 0
        
        for (stream_id,) in pending_streams:
            # Encontrar inst√¢ncia com espa√ßo
            while instance_index < len(available_instances):
                instance = available_instances[instance_index]
                if instance['current_streams'] < instance['max_streams']:
                    # Atribuir stream
                    cursor.execute("""
                        UPDATE orchestrator_stream_assignments 
                        SET server_id = %s, status = 'active', assigned_at = NOW()
                        WHERE stream_id = %s
                    """, (instance['server_id'], stream_id))
                    
                    # Atualizar contador da inst√¢ncia
                    cursor.execute("""
                        UPDATE orchestrator_instances 
                        SET current_streams = current_streams + 1
                        WHERE server_id = %s
                    """, (instance['server_id'],))
                    
                    instance['current_streams'] += 1
                    assigned_count += 1
                    
                    print(f"   ‚úÖ Stream {stream_id} ‚Üí {instance['server_id']}")
                    break
                else:
                    instance_index += 1
            
            if instance_index >= len(available_instances):
                print(f"   ‚ö†Ô∏è  N√£o h√° mais espa√ßo para atribuir streams")
                break
        
        conn.commit()
        print(f"   üìä {assigned_count} streams reatribu√≠dos")
        
        return assigned_count > 0
        
    except Exception as e:
        print(f"   ‚ùå Erro na reatribui√ß√£o: {e}")
        conn.rollback()
        return False
    finally:
        conn.close()

def main():
    """Fun√ß√£o principal"""
    print("üîÑ REBALANCEAMENTO AUTOM√ÅTICO DE STREAMS")
    print("=" * 80)
    print(f"‚è∞ Executado em: {datetime.now()}")
    
    # 1. Obter inst√¢ncias ativas
    print("\nüì° Obtendo inst√¢ncias ativas...")
    instances = get_active_instances()
    
    if not instances:
        print("‚ùå Nenhuma inst√¢ncia ativa encontrada")
        return
    
    print(f"‚úÖ Encontradas {len(instances)} inst√¢ncias ativas")
    
    # 2. Analisar necessidades de rebalanceamento
    print("\nüìä Analisando distribui√ß√£o de streams...")
    analysis = identify_rebalancing_needs(instances)
    
    print(f"   - Total de streams: {analysis['total_streams']}")
    print(f"   - Capacidade total: {analysis['total_capacity']}")
    print(f"   - Utiliza√ß√£o: {analysis['utilization']:.1f}%")
    print(f"   - Inst√¢ncias sobrecarregadas: {len(analysis['overloaded'])}")
    print(f"   - Inst√¢ncias dispon√≠veis: {len(analysis['underutilized'])}")
    
    # 3. Limpar streams √≥rf√£os
    cleanup_orphaned_streams()
    
    # 4. Executar rebalanceamento
    if analysis['overloaded']:
        perform_rebalancing(analysis)
    else:
        print("\n‚úÖ Sistema j√° est√° balanceado")
    
    # 5. Reatribuir streams pendentes
    reassign_pending_streams()
    
    # 6. Verifica√ß√£o final
    print("\nüîç Verifica√ß√£o final...")
    final_instances = get_active_instances()
    final_analysis = identify_rebalancing_needs(final_instances)
    
    print(f"\nüìä Estado final:")
    print(f"   - Total de streams: {final_analysis['total_streams']}")
    print(f"   - Utiliza√ß√£o: {final_analysis['utilization']:.1f}%")
    print(f"   - Inst√¢ncias sobrecarregadas: {len(final_analysis['overloaded'])}")
    
    if final_analysis['overloaded']:
        print("\n‚ö†Ô∏è  Ainda h√° inst√¢ncias sobrecarregadas:")
        for instance in final_analysis['overloaded']:
            print(f"   - {instance['server_id']}: {instance['current']}/{instance['max']} (+{instance['excess']})")
    else:
        print("\nüéâ Sistema totalmente balanceado!")
    
    print("\n" + "=" * 80)
    print("üèÅ REBALANCEAMENTO CONCLU√çDO")

if __name__ == "__main__":
    main()